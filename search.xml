<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode958.二叉树的完全性检验 层次遍历实现</title>
      <link href="/posts/9f6654ea.html"/>
      <url>/posts/9f6654ea.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/description/">958. 二叉树的完全性检验</a></p></blockquote><h1>完全二叉树性质</h1><ol><li><p>任一结点若<strong>有右孩子而没有左孩子</strong>，则不是完全二叉树<br><img src="/posts/9f6654ea/WechatIMG281.jpeg" alt="example"></p></li><li><p>按层次遍历顺序，第一个左右孩子不双全的结点之后的结点全是叶结点<br><img src="/posts/9f6654ea/WechatIMG282.jpeg" alt="example"></p></li></ol><h1>解题方法</h1><p>设置isLeaf变量记录结点是否为叶节点，当满足性质1后，若右孩子不存在，则isLeaf设置为1<br>其余代码即为<strong>层次遍历</strong>代码（只是在pop时加了判断条件）</p><h1>复杂度</h1><ul><li><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li></ul><h1>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="type">bool</span> isLeaf=<span class="number">0</span>; <span class="comment">//isLeaf为1，则该节点是叶节点</span></span><br><span class="line">        TreeNode* p=root;</span><br><span class="line">        que.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            p=que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件1：是叶节点但却有孩子   条件2：有右孩子但没有左孩子</span></span><br><span class="line">            <span class="keyword">if</span>((isLeaf&amp;&amp;(p-&gt;left||p-&gt;right)) || (p-&gt;right&amp;&amp;!p-&gt;left))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                isLeaf=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode98.验证二叉搜索树 中序遍历递归实现</title>
      <link href="/posts/3369928f.html"/>
      <url>/posts/3369928f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树</a></p></blockquote><h1>思路</h1><p>若该二叉树为搜索二叉树，则中序遍历后结点的值应该是递增的，所以考虑修改中序遍历递归实现的代码以达到判断是否为搜索二叉树的目的</p><h1>解题方法</h1><p>设置preValue变量记录中序遍历的到的上一个结点的值<br>对左子树调用函数，若返回0，则整个函数返回false<br>若不返回0，判断当前结点与preValue的大小，若当前结点小于等于preValue则不满足递增，返回false，反之则更新preValue的值为当前结点的值<br>对右子树递归地调用函数</p><h1>复杂度</h1><ul><li><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p></li></ul><h1>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> preValue=<span class="number">-1</span>*(<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>))<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> LeftIsBST=<span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(LeftIsBST==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=preValue)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            preValue=root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树遍历 非递归实现</title>
      <link href="/posts/e45e5cb2.html"/>
      <url>/posts/e45e5cb2.html</url>
      
        <content type="html"><![CDATA[<h1>先序遍历（根左右）</h1><ol><li>创建栈 s</li><li>压入根节点</li><li>若栈不为空，则弹栈，打印弹出结点</li><li>压入弹出结点的<strong>右孩子</strong>  （先压入右孩子后压左孩子，保证左孩子先出）</li><li>压入弹出结点的<strong>左孩子</strong></li><li>若弹出结点没有左右孩子则直接弹栈</li><li>不断循环直到栈空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderUnRecur</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//前序遍历非递归 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;preOrderUnRecur&quot;</span>&lt;&lt;endl;</span><br><span class="line">        stack&lt;node*&gt; s;</span><br><span class="line">        node* p=head;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                p=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                cout&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;rchild)  <span class="comment">//压栈先压右再压左</span></span><br><span class="line">                    s.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;lchild)</span><br><span class="line">                    s.<span class="built_in">push</span>(p-&gt;lchild);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1>后序遍历（左右根）</h1><p>先序遍历若先压左后压右则变成&quot;<strong>根右左</strong>&quot;<br>然后创建<strong>辅助栈</strong>，每从栈s弹出一个结点的同时压入辅助栈<br>最后输出辅助栈的结点，则可以实现&quot;根右左&quot;的逆序输出&quot;左右根&quot;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">posOrderUnRecur</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//后序遍历非递归 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;posOrderUnRecur&quot;</span>&lt;&lt;endl;</span><br><span class="line">        node* p=head;</span><br><span class="line">        stack&lt;node*&gt; s,s_help; <span class="comment">//主栈和辅助栈</span></span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                p=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                s_help.<span class="built_in">push</span>(p);  <span class="comment">//弹栈的同时压入辅助栈</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;lchild)  <span class="comment">//压栈先压左再压右</span></span><br><span class="line">                    s.<span class="built_in">push</span>(p-&gt;lchild);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;rchild)</span><br><span class="line">                    s.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!s_help.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;s_help.<span class="built_in">top</span>()-&gt;val&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                s_help.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1>中序遍历（左根右）</h1><ol><li>不断压入左孩子，直到左孩子为空</li><li>弹栈，输出结点</li><li>若有右孩子则压入右孩子</li><li>不断循环直到栈为空</li></ol><p><img src="/posts/e45e5cb2/WechatIMG280.jpeg" alt="例子"></p><pre><code class="language-cpp">void inOrderUnRecur(void)&#123;    node* p=head;    if(p)    &#123;        stack&lt;node*&gt; s;        while (!s.empty()||p!=nullptr)  //第二个条件保证根节点能进栈        &#123;            if(p)            &#123;                s.push(p);                p=p-&gt;lchild;  //压入左边界            &#125;else&#123;                p=s.top();                s.pop();                cout&lt;&lt;p-&gt;val&lt;&lt;' ';                p=p-&gt;rchild;  //压入右孩子的左边界            &#125;        &#125;            &#125;&#125;```</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习 变量与可变性</title>
      <link href="/posts/48d3e6cc.html"/>
      <url>/posts/48d3e6cc.html</url>
      
        <content type="html"><![CDATA[<h1>可变性</h1><p>声明变量使用 <code>let</code> 关键字<br>默认情况下，变量是不可变的（immutable）<br>在声明变量前加上 <strong>mut</strong> 关键字，使变量可变 <code>let mut x=10</code></p><h1>常量</h1><p>常量与不可变变量的区别</p><ol><li>不可以使用 mut，<strong>永远是不可变</strong>的</li><li>声明时使用 <strong>const</strong> 关键字，<strong>类型</strong>必须被标注 <code>const MAX:int32=100</code></li><li>常量可以在任何作用域内声明，包括全局作用域</li><li>只可以绑定到<strong>常量表达式</strong>，无法绑定到函数的调用结果或只能在运行时才能计算出来的值</li></ol><p>在程序运行期间，常量在其声明的作用域内<strong>一直有效</strong><br>命名规范：使用全大写字母，用下划线隔开</p><h1>shadowing（隐藏）</h1><p>可以使用相同名字声明新的变量，新的变量会 shadow 原来的变量</p><p>shadow 和把变量标记为 mut 是不一样的</p><ul><li>若不使用 let 关键字给非 mut 变量赋值会导致编译错误</li><li>let 声明的同名新变量也是<strong>不可变</strong>的</li><li>let 声明的同名新变量，类型可以与以前<strong>不同</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>=<span class="number">10</span>; <span class="comment">//a=10</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>=a+<span class="number">1</span>; <span class="comment">//a=11 type:i32</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>=<span class="string">&quot;happy&quot;</span>; <span class="comment">//type:str</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习 第一个cargo程序</title>
      <link href="/posts/e1518d3d.html"/>
      <url>/posts/e1518d3d.html</url>
      
        <content type="html"><![CDATA[<h1>创建项目</h1><p><code>cargo new name</code><br>项目名称为 name<br>会创建一个新目录 name</p><ul><li>Cargo. toml  :是Cargo的配置格式 [pacage]配置包，[dependencies]配置依赖项</li><li>src  ：放置源代码</li></ul><h1>Cargo 命令</h1><h2 id="cargo-build">cargo build</h2><ul><li>创建可执行文件 ：target/debug/name</li><li>运行可执行文件 ：./target/debug/name<br>第一次运行该命令会在顶层目录生成 cargo. lock 文件负责追踪项目依赖的精确版本</li></ul><p>若加上”–release”为发布版本</p><ul><li>编译时会进行<strong>优化</strong>，提高代码运行速度</li><li>在target/release生成可执行文件</li></ul><h2 id="cargo-run">cargo run</h2><p><strong>编译+运行</strong><br>若之前已经编译过则直接运行</p><h2 id="cargo-check">cargo check</h2><p><strong>检查代码</strong>，保证其能通过编译，但不产生可执行文件<br>比 cargo build 快，可以反复使用以检查代码</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习 环境搭建和第一个程序</title>
      <link href="/posts/3dd23104.html"/>
      <url>/posts/3dd23104.html</url>
      
        <content type="html"><![CDATA[<h1>检查环境</h1><p>查看是否成功安装 <code>cargo --version</code>   <code>rustc --version</code></p><h1>第一个程序</h1><h2 id="创建-hello-rs-文件">创建 hello. rs 文件</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译">编译</h2><p><code>rustc hello.rs</code></p><h2 id="运行">运行</h2><p><code>./hello</code></p><blockquote><p>在 macos 操作系统下</p></blockquote><h1>注意</h1><ol><li>编译和运行是单独的两步，运行 rust 程序之前必须先编译</li><li>rust 是 ahead-of-time 编译的语言，可以先编译程序，然后把可执行文件交给别人运行</li><li>rustc 只适用于简单的 rust 程序</li></ol>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程技巧 异或的使用</title>
      <link href="/posts/580e593a.html"/>
      <url>/posts/580e593a.html</url>
      
        <content type="html"><![CDATA[<h2 id="异或的性质">异或的性质</h2><p>异或即是<strong>相同为 0，不同为 1</strong></p><ol><li>0^N=N    0 与二进制数 N 进行异或的结果为 N</li><li>N^N=0</li><li>a^b= b^a   交换律</li><li>(a^b)^c=a^(b^c)    结合律</li><li>对于任意多个数异或没有顺序性</li></ol><h2 id="使用异或进行两数交换">使用异或进行两数交换</h2><p>a=a^b;<br>b=a^b;<br>a=a^b;</p><p>若a=x，b=y<br>step1:a=x^y, b=y<br>step2:a=x^y, b=x^y^y=x<br>step3:a=x^y^x=y, b=x<br>必须保证 a 与 b 所指向的内存独立（指向两块不同的内存）</p><h2 id="代码实现">代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a=a^b;</span><br><span class="line">b=a^b;</span><br><span class="line">a=a^b;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或的其他应用">异或的其他应用</h2><p><a href="https://leetcode.cn/problems/single-number/">Leetcode136</a></p><blockquote><p>若每个数组有2个非奇数个数的数a和b，其余的数都为偶数个数，则对数组中的数求异或的结果为output=a^b，然后找到output二进制形式中某个为1的位数，然后对该位为1（或0）的数进行异或得到output2=a or b ，最后output^output2即为另一个数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode142.环形链表II 双指针法</title>
      <link href="/posts/256f1857.html"/>
      <url>/posts/256f1857.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II</a></p></blockquote><h1>解题方法</h1><p>设置快指针一次走两步，慢指针一次走一步，开始时快慢指针都指向头结点<br>然后两个指针开始遍历链表，若链表无环，则快指针会走向null，若链表有环，则<strong>快慢指针会相遇</strong><br>慢指针留在相遇点，快指针返回头结点，然后快慢指针同时<strong>一次一步</strong>向后遍历，最后相遇结点即为入环首结点<br><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/">详细证明</a></p><h1>复杂度</h1><ul><li><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li></ul><h1>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast_p=head;</span><br><span class="line">        ListNode *slow_p=head;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast_p-&gt;next==<span class="literal">nullptr</span>||fast_p-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//注意终止条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            </span><br><span class="line">            fast_p=fast_p-&gt;next-&gt;next;</span><br><span class="line">            slow_p=slow_p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast_p==slow_p)  </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       fast_p=head;</span><br><span class="line">       <span class="keyword">while</span>(fast_p!=slow_p)</span><br><span class="line">       &#123;</span><br><span class="line">           fast_p=fast_p-&gt;next;</span><br><span class="line">           slow_p=slow_p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> fast_p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode160.相交链表 双指针判断</title>
      <link href="/posts/a48822be.html"/>
      <url>/posts/a48822be.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">160. 相交链表</a></p></blockquote><h1>解题方法</h1><p>首先从两个链表头结点往后遍历，记录两个链表的长度，此时遍历指针应指向末尾结点<br>若两个链表相交，则<strong>末尾结点的内存地址一定相同</strong>，以此来判断是否相交<br>然后计算长度差step，长链表指针<strong>先走step步</strong>，然后长短链表指针同时向后走，此时若遇到的第一个相同结点就是相交的首结点</p><h1>复杂度</h1><ul><li><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li></ul><h1>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *pa=headA;</span><br><span class="line">        ListNode *pb=headB;</span><br><span class="line">        <span class="type">int</span> lenA=<span class="number">0</span>,lenB=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pa-&gt;next!=<span class="literal">nullptr</span>)  <span class="comment">//计算链表A的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pb-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> step=<span class="built_in">abs</span>(lenA-lenB);  <span class="comment">//计算较长链表应先走的步数</span></span><br><span class="line">        ListNode *p=lenA&gt;=lenB?headA:headB;</span><br><span class="line">        ListNode *p1=lenA&lt;lenB?headA:headB;</span><br><span class="line">        <span class="keyword">while</span>(step&gt;<span class="number">0</span>)  <span class="comment">//长链表先走</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            step--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p!=p1)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode138.复制带随机指针的链表 原地深拷贝</title>
      <link href="/posts/d7998237.html"/>
      <url>/posts/d7998237.html</url>
      
        <content type="html"><![CDATA[<p>Problem: <a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/">138. 复制带随机指针的链表</a></p><p>[TOC]</p><h1>思路</h1><p>进行深拷贝，首先想到使用哈希表，若要求原地拷贝，则使用结点拆分的方法</p><h1>解题方法</h1><ol><li>首先不考虑random指针，将原始链表的各个结点复制并串起来</li></ol><blockquote><p>复制前：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mn>2</mn><mo>−</mo><mn>3</mn><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">1-2-3-4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span><br>复制后：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><msup><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>−</mo><mn>2</mn><mo>−</mo><msup><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>−</mo><mn>3</mn><mo>−</mo><msup><mn>3</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>−</mo><mn>4</mn><mo>−</mo><msup><mn>4</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">1-1&#x27;-2-2&#x27;-3-3&#x27;-4-4&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.835222em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.835222em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.835222em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></p></blockquote><ol start="2"><li>再次两个一组从头遍历数组p1指向前一个结点，p2指向后一个结点（也就是复制出来的结点），将复制后的结点random值指向正确位置<code>p2-&gt;random=p1-&gt;random-&gt;next</code><br><strong>已经能够保证原始结点的next指针指向复制后结点</strong></li><li>最后遍历链表，分离原始结点和复制结点</li></ol><h1>踩坑记录</h1><ol><li>记住要将原始链表还原，不然不通过</li><li>小心对null指针使用next造成内存错误访问</li></ol><h1>复杂度</h1><ul><li><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li></ul><h1>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node *p=head;</span><br><span class="line">    Node *p2;</span><br><span class="line">    <span class="comment">//Node *copy;</span></span><br><span class="line">    <span class="keyword">while</span> (p2!=<span class="literal">nullptr</span>) <span class="comment">//第一次遍历，形成复制结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p2=p-&gt;next;</span><br><span class="line">        <span class="comment">// Node copy(p-&gt;val);</span></span><br><span class="line">        Node* copy=<span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">        copy-&gt;next=p2;</span><br><span class="line">        p-&gt;next=copy;</span><br><span class="line">        p=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node *p1=head;</span><br><span class="line">    p2=p1-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p2-&gt;next==<span class="literal">nullptr</span>)  <span class="comment">//第二次遍历，处理random指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;random==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p2-&gt;random=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        p2-&gt;random=p1-&gt;random-&gt;next;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;random==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p2-&gt;random=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        p2-&gt;random=p1-&gt;random-&gt;next;&#125;</span><br><span class="line">        p2=p2-&gt;next-&gt;next;</span><br><span class="line">        p1=p1-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;random=p1-&gt;random==<span class="literal">nullptr</span>?<span class="literal">nullptr</span>:p1-&gt;random-&gt;next; <span class="comment">//重要！！！对末尾结点进行处理，循环处理不到</span></span><br><span class="line">    p1=head-&gt;next;</span><br><span class="line"></span><br><span class="line">    Node *ori_p=head;</span><br><span class="line">    Node* new_head=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p1-&gt;next!=<span class="literal">nullptr</span>)  <span class="comment">//第三次遍历，分离原始链表和复制链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        p2=p1-&gt;next-&gt;next;</span><br><span class="line">        ori_p-&gt;next=p1-&gt;next; <span class="comment">//重要！！！记住分离原始链表</span></span><br><span class="line">        ori_p=ori_p-&gt;next;</span><br><span class="line">        p1-&gt;next=p2;</span><br><span class="line">        p1=p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ori_p-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode剑指Offer51.数组中的逆序对 分治法求解</title>
      <link href="/posts/a393094e.html"/>
      <url>/posts/a393094e.html</url>
      
        <content type="html"><![CDATA[<h1>思路</h1><p>类似于<strong>归并排序</strong>，使用分治思想解决<br>要求逆序对的个数，对于数组中的每个元素，可以求在它之后且比它小的元素个数，通过分治方法可以简单实现</p><h1>解题方法</h1><p>divide：将数组分为前后两部分进行递归<br>conquer：要合并已排好序的两个子序列，设置两个指针指向数组首元素，在挑选较大元素的同时比较后一个数组指针所指的元素是否小于前一个数组指针所指的元素，若小于，则后一数组在该元素之后的元素均小于前一数组对应的元素，在计数器上加上满足要求的元素个数即可</p><h1>复杂度</h1><ul><li><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p></li></ul><h1>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1=L;</span><br><span class="line">        <span class="type">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> help[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid&amp;&amp;p2&lt;=R)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt+=vec[p1]&gt;vec[p2]?(R-p2+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">            help[i++]=vec[p1]&gt;vec[p2]?vec[p1++]:vec[p2++];  <span class="comment">//这里不能带等号，不然会漏</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid)  <span class="comment">//将有剩余元素加入数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            help[i++]=vec[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2&lt;=R)</span><br><span class="line">        &#123;</span><br><span class="line">            help[i++]=vec[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;R-L+<span class="number">1</span>;i++) <span class="comment">//将辅助空间的数据拷贝到原始数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            vec[L+i]=help[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec,<span class="type">int</span> L,<span class="type">int</span> R)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==R)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reverse</span>(vec,L,mid)+<span class="built_in">Reverse</span>(vec,mid+<span class="number">1</span>,R)+<span class="built_in">merge</span>(vec,L,R,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reverse</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode234.回文链表 快慢指针求解</title>
      <link href="/posts/84e9e2dc.html"/>
      <url>/posts/84e9e2dc.html</url>
      
        <content type="html"><![CDATA[<h1>思路</h1><p>由于是单向链表而不是双向链表，所以不能直接从两边往中间判断，考虑使用<strong>快慢指针</strong>定位链表中点位置，然后将中点之后的链表反转，这样就能完成从两边往中间判断，且不需要额外空间</p><h1>解题方法</h1><p>设置快指针fast_p，慢指针slow_p，一开始均指向链表头结点<br>快指针每走两步，慢指针走一步</p><ul><li>若链表长度为偶数，则快指针最后走到null结点，慢指针走到中间两个结点的后一个结点</li><li>若链表长度为奇数，则快指针最后走到末尾结点，慢指针走到中间结点</li></ul><p>然后将以慢指针所指结点为头结点的链表（也就是后半部分）反转即可<br>参考-&gt;<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></p><h1>踩坑记录</h1><p>1.对于用逻辑或连接的判断语句<code>if(fast_p==nullptr||fast_p-&gt;next==nullptr)</code>不能交换两个判断次序，若交换了可能出现访问null的next结点，造成错误访问（逻辑或若判断第一个条件为1，则不会判断第二个条件直接返回1）<br>2.边界条件：对于结点数较短的链表（0,1,2,3,4），最好单独进行判断，防止错误访问</p><h1>复杂度</h1><ul><li><p>时间复杂度: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度:  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li></ul><h1>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//结点数为1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//结点数为2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next-&gt;val==head-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *fast_p=head; <span class="comment">//快指针</span></span><br><span class="line">        ListNode *slow_p=head; <span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast_p==<span class="literal">nullptr</span>||fast_p-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//先判断前一个条件，若两个条件相反则出现内存错误访问</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            fast_p=fast_p-&gt;next-&gt;next; <span class="comment">//快指针走两步，慢指针走一步</span></span><br><span class="line">            slow_p=slow_p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p1,*p2,*p3;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(slow_p-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//只有四个结点时</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1=slow_p;</span><br><span class="line">            p2=p1-&gt;next;</span><br><span class="line">            p2-&gt;next=p1;</span><br><span class="line">            p1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1=slow_p;</span><br><span class="line">            p2=slow_p-&gt;next;</span><br><span class="line">            p3=slow_p-&gt;next-&gt;next;</span><br><span class="line">            p1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)  <span class="comment">//反转链表</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p3==<span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p2-&gt;next=p1;</span><br><span class="line">                p1=p2;</span><br><span class="line">                p2=p3;</span><br><span class="line">                p3=p3-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p2-&gt;next=p1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(p2-&gt;val==p-&gt;val)  <span class="comment">//左右两边往中间判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                p2=p2-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode70.爬楼梯 动态规划求解</title>
      <link href="/posts/b74d39ce.html"/>
      <url>/posts/b74d39ce.html</url>
      
        <content type="html"><![CDATA[<h3 id="解题思路">解题思路</h3><h4 id="分析">分析</h4><p>当n=1时，只有一种方法<br>当n=2时，有两种方法(走两次一级台阶或者一次走两级台阶)<br>当n=3时，<strong>可以由n=1和n=2推得n=3的情况</strong>，</p><blockquote><p>若最后一次在第三级台阶，则上一步可能在第一级台阶，后一次走了两步；也可能在第二级台阶，一次走了一步，所以到第三级台阶的方法为到第一第二级台阶方法之和<br>为什么不能在第一级台阶然后走两步到第三级台阶呢？<br>因为这样会经过第二级台阶，重复了</p></blockquote><h4 id="递推公式">递推公式</h4><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i]=dp[i-1]+dp[i-2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; stair;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        stair.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        stair.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num=stair[i<span class="number">-1</span>]+stair[i<span class="number">-2</span>];</span><br><span class="line">            stair.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stair[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火算法</title>
      <link href="/posts/a0d601b7.html"/>
      <url>/posts/a0d601b7.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-简介">1-简介</h3><p><strong>模拟退火算法（Simulated Annealing，SA）是一种模拟物理退火的过程而设计的随机优化算法</strong>，结合爬山法和随机行走算法，同时避免算法进入局部最优，早期用于组合优化，后来发展成一种通用的优化算法。</p><p>该算法采用类似于物理退火的过程，先在一个高温状态下（相当于算法随机搜索），然后逐渐退火，在每个温度下（相当于算法的每一次状态转移），徐徐冷却（相当于算法局部搜索），最终达到物理基态（相当于算法找到最优解）。</p><p><strong>高温过程</strong>——增强粒子的热运动，使其偏离平衡位置，目的是消除系统原先可能存在的非均匀态；<br><strong>等温过程</strong>——退火过程中要让温度<em>慢慢降低</em>，在每一个温度下要达到热平衡状态，对于与环境换热而温度不变的封闭系统满足自由能较少定律，系统状态的自发变化总是朝自由能减少的方向进行，当自由能达到最小时，系统达到平衡态；<br><strong>冷却过程</strong>——使粒子热运动减弱并渐趋有序，系统能量逐渐下降，从而得到低能的晶体结构。当液体凝固为固体的晶态时退火过程完成。</p><p>因此模拟退火算法从某一高温出发，在高温状态下计算初始解，然后以预设的邻域函数产生一个扰动量，从而得到新的状态，即模拟粒子的无序运动，比较新旧状态下的能量，即目标函数的解。如果新状态的能量小于旧状态，则状态发生转化；如果新状态的能量大于旧状态，则以Metropolis接受准则发生转化。当状态稳定后，便可以看作达到了当前状态的最优解，便可以开始降温，在下一个温度继续迭代，最终达到低温的稳定状态，便得到了模拟退火算法产生的结果</p><p>该算法的<strong>关键点</strong>如下： 1、对固体退火过程的模拟； 2、采用<em>Metropolis接受准则</em>  [^1]； 3、用冷却进度表控制算法进程，使算法在多项式时间里给出一个近似解。 固体退火过程是SAA的物理背景；Metropolis接受准则使算法跳离局部最优 “陷阱”；而冷却进度表的合理选择是算法应用的前提。</p><p>[^1]:  以概率接受新状态，固体在恒定温度下达到热平衡的过程可以用Monte Carlo方法（计算机随机模拟方法）加以模拟。</p><h3 id="2-原理">2-原理</h3><p>假设材料在状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 下的能量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> ，那么物体在温度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>  时从状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 进入状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 时遵循如下规律：</p><ul><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>E</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(j) &lt; E(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 则接受该状态被转化</li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>≥</mo><mi>E</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(j) \geq E(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>  则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mfrac><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><mrow><mi>K</mi><mi>T</mi></mrow></mfrac></msup></mrow><annotation encoding="application/x-tex">e^ {\frac{E(i)-E(j)}{KT}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.08945em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.08945em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0377857142857143em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.5020714285714285em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span> 概率被转化 (K是玻尔兹曼常数，T是材料温度)</li></ul><blockquote><p>由于这个过程得到的新状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 完全依赖于前一个状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 而与更前面的状态无关，所以是一个马尔可夫过程[^2]</p></blockquote><p>[^2]:每个状态值取决于前面有限个状态。（条件概率）下一个时间点的值只与当前值有关系，与以前没有关系，即未来决定于现在而不是过去。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>j</mi><mi mathvariant="normal">∣</mi><msub><mi>X</mi><mn>0</mn></msub><mo>=</mo><msub><mi>i</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><msub><mi>i</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>2</mn></msub><mo>=</mo><msub><mi>i</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>i</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo>=</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>j</mi><mi mathvariant="normal">∣</mi><msub><mi>X</mi><mi>n</mi></msub><mo>=</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X_{n+1}=j|X_0=i_0,X_1 =i_1,X_2=i_2, …,X_{n-1}= i_{n-1}, X_n = i)= P(X_{n+1}=j|X_n=i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></p><h3 id="3-案例">3-案例</h3><h4 id="观察函数图像">观察函数图像</h4><p>考察的函数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>60</mn><mi>x</mi><mo>+</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">y=3x^2-60x+9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">x_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>*x**<span class="number">2</span>-<span class="number">60</span>*x+<span class="number">9</span></span><br><span class="line">x=[i <span class="keyword">for</span> i <span class="keyword">in</span> np.linspace(<span class="number">0</span>,<span class="number">100</span>)]</span><br><span class="line">y=<span class="built_in">map</span>(x_function,x)</span><br><span class="line">plt.plot(x,<span class="built_in">list</span>(y))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">x=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 处函数取得最小值</p><h4 id="步骤">步骤</h4><h5 id="1-解空间">(1) 解空间</h5><p>解空间就是定义域的范围，在此为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,100]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></p><h5 id="2-目标函数">(2) 目标函数</h5><p>我们所要求最值的函数</p><h5 id="3-新解的产生">(3) 新解的产生</h5><p>在此案例中直接通过加上一个微小的偏差bias来微调<br><code> x_new = x + np.random.uniform(-1,1)</code><br>bias从均匀分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[-1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 中任意采样</p><h5 id="4-代价函数差">(4) 代价函数差</h5><p>为前后两次函数值的差值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(j)-E(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></p><h5 id="5-接受准则">(5) 接受准则</h5><p>为算法的核心部分</p><ul><li>if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>E</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(j)&lt;E(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 则概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">P=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>else 概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><msup><mi>e</mi><mfrac><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><mrow><mi>K</mi><mi>T</mi></mrow></mfrac></msup></mrow><annotation encoding="application/x-tex">P=e^ {\frac{E(i)-E(j)}{KT}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.08945em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.08945em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0377857142857143em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.5020714285714285em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span><br>使用中可以把K当作1处理，温度T可以是任意尺度的值(比如初始T=1)</li></ul><h5 id="6-降温">(6) 降温</h5><p>选定一个降温系数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 进行降温处理，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T=a*T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> ,以此得到新的温度(由于要缓慢降温，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 应该要接近1，比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0.999</mn></mrow><annotation encoding="application/x-tex">a=0.999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span></span></span></span>)</p><h5 id="7-结束条件">(7) 结束条件</h5><p>选定一个结束温度，当温度衰减到该值时结束算法，输出当前状态(比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>d</mi><mo>=</mo><mn>0.0000001</mn></mrow><annotation encoding="application/x-tex">std=0.0000001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span>)</p><h3 id="4-程序实现">4-程序实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">T=<span class="number">1</span> <span class="comment"># 初始温度</span></span><br><span class="line">x=np.random.uniform(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">std=<span class="number">0.0000001</span> <span class="comment"># 终止温度</span></span><br><span class="line">a=<span class="number">0.999</span> <span class="comment"># 衰减率</span></span><br><span class="line"><span class="keyword">while</span> T&gt;std:</span><br><span class="line">    y=x_function(x)</span><br><span class="line">    x_new=x+np.random.uniform(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># 产生新值</span></span><br><span class="line">    <span class="keyword">if</span> x_new&gt;=<span class="number">0</span> <span class="keyword">and</span> x_new&lt;=<span class="number">100</span>:</span><br><span class="line">        y_new=x_function(x_new)</span><br><span class="line">        <span class="keyword">if</span> y_new&lt;y:</span><br><span class="line">            x=x_new</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p=np.exp((y-y_new)/T)</span><br><span class="line">            r=np.random.uniform(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> p&gt;r:</span><br><span class="line">                x=x_new</span><br><span class="line">    T=T*a</span><br><span class="line"><span class="built_in">print</span>(x,x_function(x))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 优化算法 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/mycss.css"/>
      <url>/css/mycss.css</url>
      
        <content type="html"><![CDATA[/* 首页文章卡片 */#recent-posts > .recent-post-item{    background:rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */.card-widget{    background:rgba(255, 255, 255, 0.9)!important;}/* 文章页面正文背景 */div#post{    background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page{    background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive{    background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag{    background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category{    background: rgba(255, 255, 255, 0.9);}body {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur),        default;}a,img {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur),        default;}/* 彩带 */.card-info-avatar:hover {    background: url(https://cdn.jsdelivr.net/gh/rigodlee/BLOGCDN/img/H3342af90d24b4d62b9bbfec9688ccc25M.gif);}#web_bg {    /* 背景图地址 */    background: url(/img/backg.jpeg);    /* 平铺 */    background-repeat: no-repeat;    /* 背景图大小 */    background-size: cover;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/1292233">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p529908155.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p529908155.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>发条橙AClockworkOrange(1971)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>斯坦利·库布里克</span></div>            <div class="douban-card-item"><span>主演: </span><span>马尔科姆·麦克道威尔/帕特里克·马基</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>1971-12-19(纽约首映)</span></div>            <div class="douban-card-item"><span>评分: </span><span>8.6</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/1303460">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img1.doubanio.com/view/photo/s_ratio_poster/public/p1078004649.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img1.doubanio.com/view/photo/s_ratio_poster/public/p1078004649.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>战栗黑洞IntheMouthofMadness(1994)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>约翰·卡朋特</span></div>            <div class="douban-card-item"><span>主演: </span><span>山姆·尼尔/朱莉·卡门</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>1994-12-10(黑色电影节)</span></div>            <div class="douban-card-item"><span>评分: </span><span>7.8</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/1291557">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p1910828286.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p1910828286.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>花样年华花樣年華(2000)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>王家卫</span></div>            <div class="douban-card-item"><span>主演: </span><span>梁朝伟/张曼玉</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>2000-09-29(中国香港)</span></div>            <div class="douban-card-item"><span>评分: </span><span>8.7</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/1291999">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p792381411.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p792381411.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>重庆森林重慶森林(1994)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>王家卫</span></div>            <div class="douban-card-item"><span>主演: </span><span>林青霞/金城武</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>1994-07-14(中国香港)</span></div>            <div class="douban-card-item"><span>评分: </span><span>8.8</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/3011308">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p1592298962.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p1592298962.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>孤儿怨Orphan(2009)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>佐米·希尔拉</span></div>            <div class="douban-card-item"><span>主演: </span><span>维拉·法米加/彼得·萨斯加德</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>2009-07-24(美国/加拿大)</span></div>            <div class="douban-card-item"><span>评分: </span><span>8.2</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/3604148">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p2452537144.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p2452537144.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>小丑回魂It(2017)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>安德斯·穆斯切蒂</span></div>            <div class="douban-card-item"><span>主演: </span><span>比尔·斯卡斯加德/杰登·马泰尔</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>2017-08-29(伦敦恐怖电影节)</span></div>            <div class="douban-card-item"><span>评分: </span><span>7.4</span></div>        </div>    </a></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
