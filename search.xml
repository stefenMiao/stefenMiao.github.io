<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>本地连接服务器的Jupyter Notebook 开始炼丹</title>
      <link href="/posts/b57965de.html"/>
      <url>/posts/b57965de.html</url>
      
        <content type="html"><![CDATA[<h2 id="step1-下载Jupyter"><a href="#step1-下载Jupyter" class="headerlink" title="step1 下载Jupyter"></a>step1 下载Jupyter</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupter</span><br></pre></td></tr></table></figure><h2 id="step2-服务器中运行"><a href="#step2-服务器中运行" class="headerlink" title="step2 服务器中运行"></a>step2 服务器中运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --no-browser --port=8889</span><br></pre></td></tr></table></figure><h2 id="step3-本地机器中运行"><a href="#step3-本地机器中运行" class="headerlink" title="step3 本地机器中运行"></a>step3 本地机器中运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -N -f -L localhost:8888:localhost:8889 name@IP</span><br></pre></td></tr></table></figure><p>最后打开<a href="http://localhost:8888/">http://localhost:8888/</a> 即可</p><p>打开网址后若要求输入<strong>token</strong>，则在step3运行后终端可以获得<br><img src="/posts/b57965de/Snipaste_2023-04-16_20-17-16.png" alt="example"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -机器学习 -环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode543.二叉树的直径 递归</title>
      <link href="/posts/e12a3893.html"/>
      <url>/posts/e12a3893.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">543. 二叉树的直径</a></p></blockquote><p>[TOC]</p><h1 id="树形递归套路"><a href="#树形递归套路" class="headerlink" title="树形递归套路"></a>树形递归套路</h1><p>根结点向左右子树<strong>要信息</strong>，然后列举依靠左右子树信息计算根节点信息的情况<br>函数返回要的信息的集合</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>根结点需要左右子树的高度和两子树的最大路径长度<br>更新根节点的信息：高度为两子树的最大高度+1，最大路径长度为左右子树的最大路径长度和左右子树的高度之和再+1的最大值</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> height; <span class="comment">//记录高度</span></span><br><span class="line">    <span class="type">int</span> maxdis; <span class="comment">//记录最大路径长度</span></span><br><span class="line">    <span class="built_in">info</span>(<span class="type">int</span> h,<span class="type">int</span> md)&#123;</span><br><span class="line">        height=h;</span><br><span class="line">        maxdis=md;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        info* maxinfo=<span class="built_in">FindMax</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxinfo-&gt;maxdis<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">info* <span class="title">FindMax</span><span class="params">(TreeNode* root)</span> <span class="comment">//返回以root为根的数的直径</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">info</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        info* infoLeft=<span class="built_in">FindMax</span>(root-&gt;left);</span><br><span class="line">        info* infoRight=<span class="built_in">FindMax</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> Height=<span class="built_in">max</span>(infoLeft-&gt;height,infoRight-&gt;height)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> MaxDis=<span class="built_in">max</span>(infoLeft-&gt;maxdis,infoRight-&gt;maxdis);</span><br><span class="line">        MaxDis=<span class="built_in">max</span>(MaxDis,infoLeft-&gt;height+infoRight-&gt;height+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">info</span>(Height,MaxDis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="类型题"><a href="#类型题" class="headerlink" title="类型题"></a>类型题</h1><p><a href="https://leetcode.cn/problems/house-robber-iii/description/">337. 打家劫舍 III</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode739.每日温度 单调栈</title>
      <link href="/posts/10fcbdcb.html"/>
      <url>/posts/10fcbdcb.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/daily-temperatures/description/">739. 每日温度</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>求两侧距离<strong>最近</strong>的首个比当前元素大（或小）的元素使用<strong>单调栈</strong>解决</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>单调栈中<strong>保存索引</strong>（索引能蕴含更多信息）<br>若新元素小于等于栈顶元素，则直接进栈<br>反之若大于，则不断弹出栈中比新元素小的元素，弹出元素右边离它最近的比它大的元素就是新元素，以此来清算</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度: $O(n)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(temperatures.size(),<span class="number">0</span>)</span></span>;<span class="comment">//数组初始化全为0，可以省略最后栈中剩余元素的赋0值</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;temperatures.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[i]&lt;=temperatures[stk.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;temperatures[i]&gt;temperatures[stk.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                    res[stk.<span class="built_in">top</span>()]=i-stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode239.滑动窗口最大值 双端单调队列</title>
      <link href="/posts/5e16b3a9.html"/>
      <url>/posts/5e16b3a9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用<strong>双端队列</strong>进行维护</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>创建双端队列，存储索引，总是保持索引对应的值<strong>从大到小</strong>排列<br>若R&#x3D;0，表示窗口右边界要向右移动一位，这时若新索引对应的数据小于队列末尾索引对应的数据（1），则直接从末尾入队，若大于等于，则队列末尾索引不断出队，直到队列为空或者满足（1）关系，则新索引入队<br>若L&#x3D;0，表示窗口左边界要右移一位，比较队首元素是否等于右移前右边界的元素，若相等，则队首元素出队，反之不进行操作（就是从队列中删除超出窗口的元素）<br>通过以上两个操作能维持队列从大到小的顺序，每次队首元素即为窗口内的最大值</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度: $O(n)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="built_in">FindMax</span>(nums,que,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[<span class="built_in">FindMax</span>(nums,que,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,k<span class="number">-1</span>)]);<span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++,j++)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[<span class="built_in">FindMax</span>(nums,que,<span class="number">1</span>,<span class="number">1</span>,i,j)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,deque&lt;<span class="type">int</span>&gt; &amp;que,<span class="type">bool</span> L,<span class="type">bool</span> R,<span class="type">int</span> Lini,<span class="type">int</span> Rini)</span></span>&#123;<span class="comment">//L，R表示是否移动左右边界,Lini Rini为移动前的LR</span></span><br><span class="line">        <span class="keyword">if</span>(R)&#123;</span><br><span class="line">            <span class="keyword">if</span>(que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                que.<span class="built_in">push_back</span>(Rini+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[que.<span class="built_in">back</span>()]&gt;nums[Rini+<span class="number">1</span>])&#123;</span><br><span class="line">                    que.<span class="built_in">push_back</span>(Rini+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp;nums[que.<span class="built_in">back</span>()]&lt;=nums[Rini+<span class="number">1</span>])&#123;</span><br><span class="line">                        que.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    que.<span class="built_in">push_back</span>(Rini+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!que.<span class="built_in">empty</span>()&amp;&amp;que.<span class="built_in">front</span>()==Lini)&#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode200.岛屿数量 深度优先搜索</title>
      <link href="/posts/2cd7319b.html"/>
      <url>/posts/2cd7319b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/number-of-islands/description/">200. 岛屿数量</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>在主函数中遍历每一个点，若点上的数值为1，则进入markIslands函数，岛屿数加一<br>判断点的坐标是否违规，若不违规，则修改点的值为2，递归地调用函数修改该点上下左右点的值，直到无法继续修改</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度:  $O(n*m)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> width=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">markIslands</span>(grid,length,width,i,j);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">markIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid,<span class="type">int</span> length,<span class="type">int</span> width,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;length<span class="number">-1</span>||j&gt;width<span class="number">-1</span>||grid[i][j]!=<span class="string">&#x27;1&#x27;</span>)&#123; <span class="comment">//注意条件的顺序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="built_in">markIslands</span>(grid,length,width,i+<span class="number">1</span>,j);</span><br><span class="line">        <span class="built_in">markIslands</span>(grid,length,width,i,j+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">markIslands</span>(grid,length,width,i,j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">markIslands</span>(grid,length,width,i<span class="number">-1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode486.预测赢家 递归实现</title>
      <link href="/posts/909f4601.html"/>
      <url>/posts/909f4601.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/predict-the-winner/description/">486. 预测赢家</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><ol><li>定义先手函数和后手函数，L和R为可选数组的左右边界</li><li>当<em>先手</em>时，若L&#x3D;R只剩下一张牌，直接返回牌值，若剩下不止一张，则</li></ol><ul><li>选择最左边的牌，返回牌值加上在L+1和R范围内后手的返回值</li><li>选择最右边的牌，返回牌值加上在L和R-1范围内后手的返回值</li><li>在这两个返回值中，选择<strong>最大</strong>的（先手优势）</li></ul><ol start="3"><li>当<em>后手</em>时，若只剩下一张牌，则会被先手抽走，返回0，若不止一张，则</li></ol><ul><li>若先手选择了最左边的牌，作为后手，返回在L+1和R范围内的先手值</li><li>若先手选择了最右边的牌，作为后手，返回在L和R-1范围内的先手值</li><li>由于先手玩家总会选择最优解，故作为后手，应返回上述两者的<strong>最小值</strong>（后手劣势）</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">offensive</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>)&gt;=<span class="built_in">defensive</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">offensive</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123; <span class="comment">//先手函数，返回得分</span></span><br><span class="line">        <span class="keyword">if</span>(L==R)</span><br><span class="line">            <span class="keyword">return</span> nums[L];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums[L]+<span class="built_in">defensive</span>(nums, L+<span class="number">1</span>, R),nums[R]+<span class="built_in">defensive</span>(nums, L, R<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">defensive</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123; <span class="comment">//后手函数，返回得分</span></span><br><span class="line">        <span class="keyword">if</span>(L==R)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">offensive</span>(nums,L+<span class="number">1</span>,R),<span class="built_in">offensive</span>(nums,L,R<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode47.全排列II 递归＋分支界限</title>
      <link href="/posts/ed980a2.html"/>
      <url>/posts/ed980a2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>process函数中的参数i表示0…i-1位置上的数字已经选好，<strong>i往后所有的数字都可以选择放到i位置上</strong>（当做i位置的一种选择方式），递归地调用process函数来对i+1位置的数字进行选择<br>去重：设置visited数组记录每一个数字是否被访问过，若未访问过才进行访问（在递归过程中进行剪枝）</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">process</span>(nums,<span class="number">0</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> i,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// map&lt;int,bool&gt; visited; //使用哈希表实现（额外空间增加，不推荐）</span></span><br><span class="line">        <span class="comment">// for(int k=-10;k&lt;=10;k++)&#123; //哈希表初始化</span></span><br><span class="line">        <span class="comment">//     visited[k]=false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">bool</span> visited[<span class="number">21</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">21</span>;k++)&#123; </span><br><span class="line">            visited[k]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[nums[j]+<span class="number">10</span>])&#123;</span><br><span class="line">                visited[nums[j]+<span class="number">10</span>]=<span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">                <span class="built_in">process</span>(nums,i+<span class="number">1</span>, res);</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[j]); <span class="comment">//还原，保证原数组不变</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 分支界限 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode295.数据流的中位数 堆实现</title>
      <link href="/posts/c988aa36.html"/>
      <url>/posts/c988aa36.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/find-median-from-data-stream/description/">295. 数据流的中位数</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><ol><li>建立大根堆bigHeap和小根堆smallHeap</li><li>更新：新加入一个数num，若大根堆为空则直接加入大根堆；若大根堆不为空，判断num与大根堆堆顶元素的大小关系，若num<strong>小于堆顶元素</strong>，则加入大根堆，反之加入小根堆</li><li>维护：若大根堆与小根堆的元素个数<strong>相差超过1</strong>，则元素个数多的堆弹出元素放入少的堆</li></ol><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度: $O(n)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; bigHeap;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; smallHeap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bigHeap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            bigHeap.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;bigHeap.<span class="built_in">top</span>())&#123;</span><br><span class="line">            bigHeap.<span class="built_in">push</span>(num);      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        smallHeap.<span class="built_in">push</span>(num);&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">int</span>(bigHeap.<span class="built_in">size</span>()-smallHeap.<span class="built_in">size</span>())&gt;<span class="number">1</span>)&#123; <span class="comment">//坑 不加int时为unsigned int，为负数时越界</span></span><br><span class="line">        smallHeap.<span class="built_in">push</span>(bigHeap.<span class="built_in">top</span>());</span><br><span class="line">        bigHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">int</span>(smallHeap.<span class="built_in">size</span>()-bigHeap.<span class="built_in">size</span>())&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        bigHeap.<span class="built_in">push</span>(smallHeap.<span class="built_in">top</span>());</span><br><span class="line">        smallHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bigHeap.<span class="built_in">size</span>()==smallHeap.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> (bigHeap.<span class="built_in">top</span>()+smallHeap.<span class="built_in">top</span>())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bigHeap.<span class="built_in">size</span>()&gt;smallHeap.<span class="built_in">size</span>()?bigHeap.<span class="built_in">top</span>():smallHeap.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode646.最长数对链 贪心实现</title>
      <link href="/posts/fcba0455.html"/>
      <url>/posts/fcba0455.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/description/">646. 最长数对链</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>贪心算法，优先选取<strong>末尾元素较小</strong>的数对（保证后面有更大的空间放更多的数对）</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><ol><li>将数对按照第二个元素进行升序排序</li><li>定义数对指针指向已选的最后一个数对的末尾元素</li><li>遍历数对数组，若新的数对的首元素大于数对指针（保证数对之间不重叠），则可选数对数量增加</li></ol><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度: $O(1)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123; <span class="comment">//定义排序函数</span></span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">back</span>()&lt;b.<span class="built_in">back</span>();  <span class="comment">//vector中第二个元素的升序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongestChain</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(),pairs.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>; <span class="comment">//记录数对链中数对个数</span></span><br><span class="line">        <span class="type">long</span> point=-<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">32</span>)<span class="number">-1</span>; <span class="comment">//数对指针</span></span><br><span class="line">        <span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator iter=pairs.<span class="built_in">begin</span>();iter!=pairs.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*iter-&gt;<span class="built_in">begin</span>()&gt;point)&#123;</span><br><span class="line">                point=(*iter).<span class="built_in">back</span>(); <span class="comment">//注意这里的括号</span></span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode210.课程表II 拓扑排序</title>
      <link href="/posts/3ee9e18d.html"/>
      <url>/posts/3ee9e18d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/course-schedule-ii/description/">210. 课程表 II</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>建立一个队列初始化保存<strong>入度为零</strong>的结点<br>若队列不为空，则不断出队，出队结点放入结果向量中保存，将出队结点的入度减一，若出现新的入度为零的结点，则将其入队  </p><h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><ol><li>只有一门课程时，直接返回该课程</li><li>若图中有环，则出队结点数<strong>小于</strong>总节点数，无法满足选择全部课程，则返回空<code>return &#123;&#125;</code></li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> num; <span class="comment">//编号 </span></span><br><span class="line">        <span class="type">int</span> inNum=<span class="number">0</span>; <span class="comment">//入度</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nextNode; <span class="comment">//下一个邻接节点</span></span><br><span class="line">    &#125;Node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createGraph</span><span class="params">(vector&lt;Node&gt; &amp;nodes,<span class="type">int</span> numCourses,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; prerequisites)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator iter=prerequisites.<span class="built_in">begin</span>();</span><br><span class="line">            Node* n=<span class="keyword">new</span> Node;</span><br><span class="line">            n-&gt;num=i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(iter!=prerequisites.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>((*iter).<span class="built_in">back</span>()==i)&#123;</span><br><span class="line">                    n-&gt;nextNode.<span class="built_in">push_back</span>((*iter).<span class="built_in">front</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((*iter).<span class="built_in">front</span>()==i)&#123;</span><br><span class="line">                    n-&gt;inNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                iter++;</span><br><span class="line">            &#125;</span><br><span class="line">            nodes.<span class="built_in">push_back</span>(*n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;Node&gt; nodes;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; correct;</span><br><span class="line">        <span class="keyword">if</span>(numCourses==<span class="number">1</span>)&#123;</span><br><span class="line">            correct.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> correct;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">createGraph</span>(nodes, numCourses, prerequisites);</span><br><span class="line">        queue&lt;Node&gt; InZeroQue; <span class="comment">//存放入度为零的结点的队列</span></span><br><span class="line">         <span class="comment">//存放正确顺序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        vector&lt;Node&gt;::iterator iter=nodes.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(iter!=nodes.<span class="built_in">end</span>())&#123; <span class="comment">//初始化队列</span></span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;inNum==<span class="number">0</span>)&#123;</span><br><span class="line">                InZeroQue.<span class="built_in">push</span>(*iter);</span><br><span class="line">            &#125;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(InZeroQue.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;; <span class="comment">//若无入度为零的结点，返回空</span></span><br><span class="line">        <span class="keyword">while</span>(!InZeroQue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Node p=InZeroQue.<span class="built_in">front</span>();</span><br><span class="line">            InZeroQue.<span class="built_in">pop</span>();</span><br><span class="line">            flag++;</span><br><span class="line">            correct.<span class="built_in">push_back</span>(p.num); <span class="comment">// 课程编号存入数组</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;::iterator iter1=p.nextNode.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(iter1!=p.nextNode.<span class="built_in">end</span>())&#123;</span><br><span class="line">                nodes[*iter1].inNum--;</span><br><span class="line">                <span class="keyword">if</span>(nodes[*iter1].inNum==<span class="number">0</span>)&#123;</span><br><span class="line">                    InZeroQue.<span class="built_in">push</span>(nodes[*iter1]);</span><br><span class="line">                &#125;</span><br><span class="line">                iter1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag!=numCourses)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;; <span class="comment">//出队结点个数不等于总节点个数，则有环 </span></span><br><span class="line">        <span class="keyword">return</span> correct;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 图 </tag>
            
            <tag> 队列 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode297.二叉树的序列化与反序列化 先序遍历实现</title>
      <link href="/posts/d2e02684.html"/>
      <url>/posts/d2e02684.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><ol><li>序列化：使用<strong>先序遍历</strong>，将树变为字符串存储，null结点存储为#，用”_”分割  </li><li>反序列化：对于得到的前序数组，若弹出首元素，若弹出元素为空，则返回null，若不为空，则递归地构建左子树和右子树</li></ol><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><ol><li>要使用<strong>atoi</strong>函数将string转换为int，必须使用c_str()方法，将string转换为c_str</li><li>使用迭代器删除vector首元素（vec.erase(vec.begin())），必须保证vector不为空</li><li>字符串分割自己写了一个函数实现</li><li>单引号是字符型，双引号是字符串型</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> nullnode -2000</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">//序列化</span></span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#_&quot;</span>;</span><br><span class="line">        string res=<span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot;_&quot;</span>;</span><br><span class="line">        res += <span class="built_in">serialize</span>(root-&gt;left);</span><br><span class="line">        res += <span class="built_in">serialize</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parseString</span><span class="params">(vector&lt;string&gt; &amp;v,<span class="type">const</span> string &amp; s,string sp)</span> <span class="comment">//按照sp分割字符串</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> st=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pos=s.<span class="built_in">find</span>(sp,st);</span><br><span class="line">            <span class="keyword">if</span>(pos==string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(st));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(st,pos-st));</span><br><span class="line">                st=pos+sp.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stringToVec</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec,string data)</span></span>&#123; <span class="comment">//将string转换为vector&lt;int&gt;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> len=data.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;string&gt; split_data;</span><br><span class="line">        <span class="built_in">parseString</span>(split_data, data, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;split_data.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(split_data[i]==<span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(nullnode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vec.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(split_data[i].<span class="built_in">c_str</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">ToTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span>&#123; <span class="comment">//将vector转换为树</span></span><br><span class="line">        <span class="type">int</span> num=vec.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>())  <span class="comment">//需要保证vec内有元素，否则会报错，无法返回迭代器</span></span><br><span class="line">            vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span>(num==nullnode)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* head=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">        head-&gt;left=<span class="built_in">ToTree</span>(vec);</span><br><span class="line">        head-&gt;right=<span class="built_in">ToTree</span>(vec);</span><br><span class="line">        <span class="keyword">return</span> head;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123; <span class="comment">//反序列化</span></span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nodeVal;</span><br><span class="line">        <span class="built_in">stringToVec</span>(nodeVal,data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ToTree</span>(nodeVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode236.二叉树的最近公共祖先 递归实现</title>
      <link href="/posts/37e6f34.html"/>
      <url>/posts/37e6f34.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先</a></p></blockquote><h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><p>建立哈希表，存储每个结点的父节点<br>建立集合存储p的所有祖先结点<br>在p的祖先结点集合中找有没有q的祖先结点</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        map&lt;TreeNode*,TreeNode*&gt; faMap;</span><br><span class="line">        faMap[root]=root;</span><br><span class="line">        <span class="built_in">getFather</span>(root, faMap);</span><br><span class="line"></span><br><span class="line">        set&lt;TreeNode*&gt; nodeSet;</span><br><span class="line">        TreeNode* cur=p;</span><br><span class="line">        <span class="keyword">while</span>(cur!=root)&#123;</span><br><span class="line">            nodeSet.<span class="built_in">insert</span>(cur);</span><br><span class="line">            cur=faMap[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        nodeSet.<span class="built_in">insert</span>(root);</span><br><span class="line">        cur =q;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodeSet.<span class="built_in">find</span>(cur)!=nodeSet.<span class="built_in">end</span>())&#123;<span class="comment">//在p的父节点集合中找到q的父节点</span></span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=faMap[cur];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取每一个结点的父节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getFather</span><span class="params">(TreeNode* root,map&lt;TreeNode*,TreeNode*&gt; &amp;faMap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        faMap[root-&gt;left]=root;</span><br><span class="line">        faMap[root-&gt;right]=root;</span><br><span class="line">        <span class="built_in">getFather</span>(root-&gt;left, faMap);</span><br><span class="line">        <span class="built_in">getFather</span>(root-&gt;right, faMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><p>若到达空结点或要求的目标结点，则直接返回<br>在左右子树递归调用<br>如果调用结果都不为空，则该节点为第一个共同祖先，返回<br>反之则返回不为空的结点</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>||root==p||root==q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* leftNode=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* rightNode=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(leftNode&amp;&amp;rightNode)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> leftNode?leftNode:rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode958.二叉树的完全性检验 层次遍历实现</title>
      <link href="/posts/9f6654ea.html"/>
      <url>/posts/9f6654ea.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/description/">958. 二叉树的完全性检验</a></p></blockquote><h1 id="完全二叉树性质"><a href="#完全二叉树性质" class="headerlink" title="完全二叉树性质"></a>完全二叉树性质</h1><ol><li><p>任一结点若<strong>有右孩子而没有左孩子</strong>，则不是完全二叉树<br><img src="/posts/9f6654ea/WechatIMG281.jpeg" alt="example"></p></li><li><p>按层次遍历顺序，第一个左右孩子不双全的结点之后的结点全是叶结点<br><img src="/posts/9f6654ea/WechatIMG282.jpeg" alt="example"></p></li></ol><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>设置isLeaf变量记录结点是否为叶节点，当满足性质1后，若右孩子不存在，则isLeaf设置为1<br>其余代码即为<strong>层次遍历</strong>代码（只是在pop时加了判断条件）</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度: $O(1)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="type">bool</span> isLeaf=<span class="number">0</span>; <span class="comment">//isLeaf为1，则该节点是叶节点</span></span><br><span class="line">        TreeNode* p=root;</span><br><span class="line">        que.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            p=que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件1：是叶节点但却有孩子   条件2：有右孩子但没有左孩子</span></span><br><span class="line">            <span class="keyword">if</span>((isLeaf&amp;&amp;(p-&gt;left||p-&gt;right)) || (p-&gt;right&amp;&amp;!p-&gt;left))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                isLeaf=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode98.验证二叉搜索树 中序遍历递归实现</title>
      <link href="/posts/3369928f.html"/>
      <url>/posts/3369928f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>若该二叉树为搜索二叉树，则中序遍历后结点的值应该是递增的，所以考虑修改中序遍历递归实现的代码以达到判断是否为搜索二叉树的目的</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>设置preValue变量记录中序遍历的到的上一个结点的值<br>对左子树调用函数，若返回0，则整个函数返回false<br>若不返回0，判断当前结点与preValue的大小，若当前结点小于等于preValue则不满足递增，返回false，反之则更新preValue的值为当前结点的值<br>对右子树递归地调用函数</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度: $O(n)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> preValue=<span class="number">-1</span>*(<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>))<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> LeftIsBST=<span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(LeftIsBST==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=preValue)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            preValue=root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树遍历 非递归实现</title>
      <link href="/posts/e45e5cb2.html"/>
      <url>/posts/e45e5cb2.html</url>
      
        <content type="html"><![CDATA[<h1 id="先序遍历（根左右）"><a href="#先序遍历（根左右）" class="headerlink" title="先序遍历（根左右）"></a>先序遍历（根左右）</h1><ol><li>创建栈 s</li><li>压入根节点</li><li>若栈不为空，则弹栈，打印弹出结点</li><li>压入弹出结点的<strong>右孩子</strong>  （先压入右孩子后压左孩子，保证左孩子先出）</li><li>压入弹出结点的<strong>左孩子</strong></li><li>若弹出结点没有左右孩子则直接弹栈</li><li>不断循环直到栈空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderUnRecur</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//前序遍历非递归 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;preOrderUnRecur&quot;</span>&lt;&lt;endl;</span><br><span class="line">        stack&lt;node*&gt; s;</span><br><span class="line">        node* p=head;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                p=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                cout&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;rchild)  <span class="comment">//压栈先压右再压左</span></span><br><span class="line">                    s.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;lchild)</span><br><span class="line">                    s.<span class="built_in">push</span>(p-&gt;lchild);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="后序遍历（左右根）"><a href="#后序遍历（左右根）" class="headerlink" title="后序遍历（左右根）"></a>后序遍历（左右根）</h1><p>先序遍历若先压左后压右则变成”<strong>根右左</strong>“<br>然后创建<strong>辅助栈</strong>，每从栈s弹出一个结点的同时压入辅助栈<br>最后输出辅助栈的结点，则可以实现”根右左”的逆序输出”左右根”  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">posOrderUnRecur</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//后序遍历非递归 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;posOrderUnRecur&quot;</span>&lt;&lt;endl;</span><br><span class="line">        node* p=head;</span><br><span class="line">        stack&lt;node*&gt; s,s_help; <span class="comment">//主栈和辅助栈</span></span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                p=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                s_help.<span class="built_in">push</span>(p);  <span class="comment">//弹栈的同时压入辅助栈</span></span><br><span class="line">                <span class="keyword">if</span>(p-&gt;lchild)  <span class="comment">//压栈先压左再压右</span></span><br><span class="line">                    s.<span class="built_in">push</span>(p-&gt;lchild);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;rchild)</span><br><span class="line">                    s.<span class="built_in">push</span>(p-&gt;rchild);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!s_help.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;s_help.<span class="built_in">top</span>()-&gt;val&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                s_help.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历（左根右）"><a href="#中序遍历（左根右）" class="headerlink" title="中序遍历（左根右）"></a>中序遍历（左根右）</h1><ol><li>不断压入左孩子，直到左孩子为空</li><li>弹栈，输出结点</li><li>若有右孩子则压入右孩子</li><li>不断循环直到栈为空</li></ol><p><img src="/posts/e45e5cb2/e45e5cb2/WechatIMG280.jpeg" alt="例子"></p><p>&#96;&#96;&#96;cpp<br>void inOrderUnRecur(void)<br>{<br>    node* p&#x3D;head;<br>    if(p)<br>    {<br>        stack&lt;node*&gt; s;<br>        while (!s.empty()||p!&#x3D;nullptr)  &#x2F;&#x2F;第二个条件保证根节点能进栈<br>        {<br>            if(p)<br>            {<br>                s.push(p);<br>                p&#x3D;p-&gt;lchild;  &#x2F;&#x2F;压入左边界<br>            }else{<br>                p&#x3D;s.top();<br>                s.pop();<br>                cout&lt;<p->val&lt;&lt;’ ‘;<br>                p&#x3D;p-&gt;rchild;  &#x2F;&#x2F;压入右孩子的左边界<br>            }<br>        }</p-></p><pre><code>&#125;</code></pre><p>}&#96;&#96;&#96;</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习 变量与可变性</title>
      <link href="/posts/48d3e6cc.html"/>
      <url>/posts/48d3e6cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h1><p>声明变量使用 <code>let</code> 关键字<br>默认情况下，变量是不可变的（immutable）<br>在声明变量前加上 <strong>mut</strong> 关键字，使变量可变 <code>let mut x=10</code>   </p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量与不可变变量的区别  </p><ol><li>不可以使用 mut，<strong>永远是不可变</strong>的</li><li>声明时使用 <strong>const</strong> 关键字，<strong>类型</strong>必须被标注 <code>const MAX:int32=100</code></li><li>常量可以在任何作用域内声明，包括全局作用域</li><li>只可以绑定到<strong>常量表达式</strong>，无法绑定到函数的调用结果或只能在运行时才能计算出来的值</li></ol><p>在程序运行期间，常量在其声明的作用域内<strong>一直有效</strong><br>命名规范：使用全大写字母，用下划线隔开</p><h1 id="shadowing（隐藏）"><a href="#shadowing（隐藏）" class="headerlink" title="shadowing（隐藏）"></a>shadowing（隐藏）</h1><p>可以使用相同名字声明新的变量，新的变量会 shadow 原来的变量  </p><p>shadow 和把变量标记为 mut 是不一样的</p><ul><li>若不使用 let 关键字给非 mut 变量赋值会导致编译错误</li><li>let 声明的同名新变量也是<strong>不可变</strong>的</li><li>let 声明的同名新变量，类型可以与以前<strong>不同</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>=<span class="number">10</span>; <span class="comment">//a=10</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>=a+<span class="number">1</span>; <span class="comment">//a=11 type:i32</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>=<span class="string">&quot;happy&quot;</span>; <span class="comment">//type:str</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习 第一个cargo程序</title>
      <link href="/posts/e1518d3d.html"/>
      <url>/posts/e1518d3d.html</url>
      
        <content type="html"><![CDATA[<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p><code>cargo new name</code><br>项目名称为 name<br>会创建一个新目录 name  </p><ul><li>Cargo. toml  :是Cargo的配置格式 [pacage]配置包，[dependencies]配置依赖项</li><li>src  ：放置源代码</li></ul><h1 id="Cargo-命令"><a href="#Cargo-命令" class="headerlink" title="Cargo 命令"></a>Cargo 命令</h1><h2 id="cargo-build"><a href="#cargo-build" class="headerlink" title="cargo build"></a>cargo build</h2><ul><li>创建可执行文件 ：target&#x2F;debug&#x2F;name</li><li>运行可执行文件 ：.&#x2F;target&#x2F;debug&#x2F;name<br>第一次运行该命令会在顶层目录生成 cargo. lock 文件负责追踪项目依赖的精确版本</li></ul><p>若加上”–release”为发布版本</p><ul><li>编译时会进行<strong>优化</strong>，提高代码运行速度  </li><li>在target&#x2F;release生成可执行文件</li></ul><h2 id="cargo-run"><a href="#cargo-run" class="headerlink" title="cargo run"></a>cargo run</h2><p><strong>编译+运行</strong><br>若之前已经编译过则直接运行</p><h2 id="cargo-check"><a href="#cargo-check" class="headerlink" title="cargo check"></a>cargo check</h2><p><strong>检查代码</strong>，保证其能通过编译，但不产生可执行文件<br>比 cargo build 快，可以反复使用以检查代码  </p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习 环境搭建和第一个程序</title>
      <link href="/posts/3dd23104.html"/>
      <url>/posts/3dd23104.html</url>
      
        <content type="html"><![CDATA[<h1 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h1><p>查看是否成功安装 <code>cargo --version</code>   <code>rustc --version</code></p><h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><h2 id="创建-hello-rs-文件"><a href="#创建-hello-rs-文件" class="headerlink" title="创建 hello. rs 文件"></a>创建 hello. rs 文件</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><code>rustc hello.rs</code></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>./hello</code>   </p><blockquote><p>在 macos 操作系统下</p></blockquote><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li>编译和运行是单独的两步，运行 rust 程序之前必须先编译</li><li>rust 是 ahead-of-time 编译的语言，可以先编译程序，然后把可执行文件交给别人运行</li><li>rustc 只适用于简单的 rust 程序</li></ol>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程技巧 异或的使用</title>
      <link href="/posts/580e593a.html"/>
      <url>/posts/580e593a.html</url>
      
        <content type="html"><![CDATA[<h2 id="异或的性质"><a href="#异或的性质" class="headerlink" title="异或的性质"></a>异或的性质</h2><p>异或即是<strong>相同为 0，不同为 1</strong></p><ol><li>0^N&#x3D;N    0 与二进制数 N 进行异或的结果为 N</li><li>N^N&#x3D;0</li><li>a^b&#x3D; b^a   交换律</li><li>(a^b)^c&#x3D;a^(b^c)    结合律</li><li>对于任意多个数异或没有顺序性</li></ol><h2 id="使用异或进行两数交换"><a href="#使用异或进行两数交换" class="headerlink" title="使用异或进行两数交换"></a>使用异或进行两数交换</h2><p>a&#x3D;a^b;<br>b&#x3D;a^b;<br>a&#x3D;a^b;</p><p>若a&#x3D;x，b&#x3D;y<br>step1:a&#x3D;x^y, b&#x3D;y<br>step2:a&#x3D;x^y, b&#x3D;x^y^y&#x3D;x<br>step3:a&#x3D;x^y^x&#x3D;y, b&#x3D;x<br>必须保证 a 与 b 所指向的内存独立（指向两块不同的内存）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a=a^b;</span><br><span class="line">b=a^b;</span><br><span class="line">a=a^b;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或的其他应用"><a href="#异或的其他应用" class="headerlink" title="异或的其他应用"></a>异或的其他应用</h2><p><a href="https://leetcode.cn/problems/single-number/">Leetcode136</a></p><blockquote><p>若每个数组有2个非奇数个数的数a和b，其余的数都为偶数个数，则对数组中的数求异或的结果为output&#x3D;a^b，然后找到output二进制形式中某个为1的位数，然后对该位为1（或0）的数进行异或得到output2&#x3D;a or b ，最后output^output2即为另一个数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode142.环形链表II 双指针法</title>
      <link href="/posts/256f1857.html"/>
      <url>/posts/256f1857.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>设置快指针一次走两步，慢指针一次走一步，开始时快慢指针都指向头结点<br>然后两个指针开始遍历链表，若链表无环，则快指针会走向null，若链表有环，则<strong>快慢指针会相遇</strong><br>慢指针留在相遇点，快指针返回头结点，然后快慢指针同时<strong>一次一步</strong>向后遍历，最后相遇结点即为入环首结点<br><a href="https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/">详细证明</a></p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度: $O(1)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast_p=head;</span><br><span class="line">        ListNode *slow_p=head;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast_p-&gt;next==<span class="literal">nullptr</span>||fast_p-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//注意终止条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            </span><br><span class="line">            fast_p=fast_p-&gt;next-&gt;next;</span><br><span class="line">            slow_p=slow_p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast_p==slow_p)  </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       fast_p=head;</span><br><span class="line">       <span class="keyword">while</span>(fast_p!=slow_p)</span><br><span class="line">       &#123;</span><br><span class="line">           fast_p=fast_p-&gt;next;</span><br><span class="line">           slow_p=slow_p-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> fast_p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode160.相交链表 双指针判断</title>
      <link href="/posts/a48822be.html"/>
      <url>/posts/a48822be.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">160. 相交链表</a></p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>首先从两个链表头结点往后遍历，记录两个链表的长度，此时遍历指针应指向末尾结点<br>若两个链表相交，则<strong>末尾结点的内存地址一定相同</strong>，以此来判断是否相交<br>然后计算长度差step，长链表指针<strong>先走step步</strong>，然后长短链表指针同时向后走，此时若遇到的第一个相同结点就是相交的首结点</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度: $O(1)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *pa=headA;</span><br><span class="line">        ListNode *pb=headB;</span><br><span class="line">        <span class="type">int</span> lenA=<span class="number">0</span>,lenB=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pa-&gt;next!=<span class="literal">nullptr</span>)  <span class="comment">//计算链表A的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pb-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pa!=pb)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> step=<span class="built_in">abs</span>(lenA-lenB);  <span class="comment">//计算较长链表应先走的步数</span></span><br><span class="line">        ListNode *p=lenA&gt;=lenB?headA:headB;</span><br><span class="line">        ListNode *p1=lenA&lt;lenB?headA:headB;</span><br><span class="line">        <span class="keyword">while</span>(step&gt;<span class="number">0</span>)  <span class="comment">//长链表先走</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            step--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p!=p1)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode138.复制带随机指针的链表 原地深拷贝</title>
      <link href="/posts/d7998237.html"/>
      <url>/posts/d7998237.html</url>
      
        <content type="html"><![CDATA[<p>Problem: <a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/">138. 复制带随机指针的链表</a></p><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>进行深拷贝，首先想到使用哈希表，若要求原地拷贝，则使用结点拆分的方法</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><ol><li><p>首先不考虑random指针，将原始链表的各个结点复制并串起来  </p><blockquote><p>复制前：$1-2-3-4$<br>复制后：$1-1’-2-2’-3-3’-4-4’$</p></blockquote></li><li><p>再次两个一组从头遍历数组p1指向前一个结点，p2指向后一个结点（也就是复制出来的结点），将复制后的结点random值指向正确位置<code>p2-&gt;random=p1-&gt;random-&gt;next</code><br><strong>已经能够保证原始结点的next指针指向复制后结点</strong>  </p></li><li><p>最后遍历链表，分离原始结点和复制结点</p></li></ol><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><ol><li>记住要将原始链表还原，不然不通过  </li><li>小心对null指针使用next造成内存错误访问</li></ol><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度: $O(1)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node *p=head;</span><br><span class="line">    Node *p2;</span><br><span class="line">    <span class="comment">//Node *copy;</span></span><br><span class="line">    <span class="keyword">while</span> (p2!=<span class="literal">nullptr</span>) <span class="comment">//第一次遍历，形成复制结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p2=p-&gt;next;</span><br><span class="line">        <span class="comment">// Node copy(p-&gt;val);</span></span><br><span class="line">        Node* copy=<span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">        copy-&gt;next=p2;</span><br><span class="line">        p-&gt;next=copy;</span><br><span class="line">        p=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node *p1=head;</span><br><span class="line">    p2=p1-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p2-&gt;next==<span class="literal">nullptr</span>)  <span class="comment">//第二次遍历，处理random指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;random==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p2-&gt;random=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        p2-&gt;random=p1-&gt;random-&gt;next;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;random==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p2-&gt;random=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        p2-&gt;random=p1-&gt;random-&gt;next;&#125;</span><br><span class="line">        p2=p2-&gt;next-&gt;next;</span><br><span class="line">        p1=p1-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;random=p1-&gt;random==<span class="literal">nullptr</span>?<span class="literal">nullptr</span>:p1-&gt;random-&gt;next; <span class="comment">//重要！！！对末尾结点进行处理，循环处理不到</span></span><br><span class="line">    p1=head-&gt;next;</span><br><span class="line"></span><br><span class="line">    Node *ori_p=head;</span><br><span class="line">    Node* new_head=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p1-&gt;next!=<span class="literal">nullptr</span>)  <span class="comment">//第三次遍历，分离原始链表和复制链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        p2=p1-&gt;next-&gt;next;</span><br><span class="line">        ori_p-&gt;next=p1-&gt;next; <span class="comment">//重要！！！记住分离原始链表</span></span><br><span class="line">        ori_p=ori_p-&gt;next;</span><br><span class="line">        p1-&gt;next=p2;</span><br><span class="line">        p1=p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ori_p-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode剑指Offer51.数组中的逆序对 分治法求解</title>
      <link href="/posts/a393094e.html"/>
      <url>/posts/a393094e.html</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>类似于<strong>归并排序</strong>，使用分治思想解决<br>要求逆序对的个数，对于数组中的每个元素，可以求在它之后且比它小的元素个数，通过分治方法可以简单实现</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>divide：将数组分为前后两部分进行递归<br>conquer：要合并已排好序的两个子序列，设置两个指针指向数组首元素，在挑选较大元素的同时比较后一个数组指针所指的元素是否小于前一个数组指针所指的元素，若小于，则后一数组在该元素之后的元素均小于前一数组对应的元素，在计数器上加上满足要求的元素个数即可</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(nlogn)$</p></li><li><p>空间复杂度: $O(n)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1=L;</span><br><span class="line">        <span class="type">int</span> p2=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> help[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid&amp;&amp;p2&lt;=R)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt+=vec[p1]&gt;vec[p2]?(R-p2+<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">            help[i++]=vec[p1]&gt;vec[p2]?vec[p1++]:vec[p2++];  <span class="comment">//这里不能带等号，不然会漏</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=mid)  <span class="comment">//将有剩余元素加入数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            help[i++]=vec[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2&lt;=R)</span><br><span class="line">        &#123;</span><br><span class="line">            help[i++]=vec[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;R-L+<span class="number">1</span>;i++) <span class="comment">//将辅助空间的数据拷贝到原始数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            vec[L+i]=help[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec,<span class="type">int</span> L,<span class="type">int</span> R)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==R)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reverse</span>(vec,L,mid)+<span class="built_in">Reverse</span>(vec,mid+<span class="number">1</span>,R)+<span class="built_in">merge</span>(vec,L,R,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reverse</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode234.回文链表 快慢指针求解</title>
      <link href="/posts/84e9e2dc.html"/>
      <url>/posts/84e9e2dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于是单向链表而不是双向链表，所以不能直接从两边往中间判断，考虑使用<strong>快慢指针</strong>定位链表中点位置，然后将中点之后的链表反转，这样就能完成从两边往中间判断，且不需要额外空间</p><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>设置快指针fast_p，慢指针slow_p，一开始均指向链表头结点<br>快指针每走两步，慢指针走一步  </p><ul><li>若链表长度为偶数，则快指针最后走到null结点，慢指针走到中间两个结点的后一个结点  </li><li>若链表长度为奇数，则快指针最后走到末尾结点，慢指针走到中间结点</li></ul><p>然后将以慢指针所指结点为头结点的链表（也就是后半部分）反转即可<br>参考-&gt;<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></p><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>1.对于用逻辑或连接的判断语句<code>if(fast_p==nullptr||fast_p-&gt;next==nullptr)</code>不能交换两个判断次序，若交换了可能出现访问null的next结点，造成错误访问（逻辑或若判断第一个条件为1，则不会判断第二个条件直接返回1）<br>2.边界条件：对于结点数较短的链表（0,1,2,3,4），最好单独进行判断，防止错误访问</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n)$</p></li><li><p>空间复杂度:  $O(1)$</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//结点数为1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//结点数为2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next-&gt;val==head-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *fast_p=head; <span class="comment">//快指针</span></span><br><span class="line">        ListNode *slow_p=head; <span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast_p==<span class="literal">nullptr</span>||fast_p-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//先判断前一个条件，若两个条件相反则出现内存错误访问</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            fast_p=fast_p-&gt;next-&gt;next; <span class="comment">//快指针走两步，慢指针走一步</span></span><br><span class="line">            slow_p=slow_p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p1,*p2,*p3;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(slow_p-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="comment">//只有四个结点时</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1=slow_p;</span><br><span class="line">            p2=p1-&gt;next;</span><br><span class="line">            p2-&gt;next=p1;</span><br><span class="line">            p1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1=slow_p;</span><br><span class="line">            p2=slow_p-&gt;next;</span><br><span class="line">            p3=slow_p-&gt;next-&gt;next;</span><br><span class="line">            p1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)  <span class="comment">//反转链表</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p3==<span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p2-&gt;next=p1;</span><br><span class="line">                p1=p2;</span><br><span class="line">                p2=p3;</span><br><span class="line">                p3=p3-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p2-&gt;next=p1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(p2-&gt;val==p-&gt;val)  <span class="comment">//左右两边往中间判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                p2=p2-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode70.爬楼梯 动态规划求解</title>
      <link href="/posts/b74d39ce.html"/>
      <url>/posts/b74d39ce.html</url>
      
        <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>当n&#x3D;1时，只有一种方法<br>当n&#x3D;2时，有两种方法(走两次一级台阶或者一次走两级台阶)<br>当n&#x3D;3时，<strong>可以由n&#x3D;1和n&#x3D;2推得n&#x3D;3的情况</strong>，</p><blockquote><p>若最后一次在第三级台阶，则上一步可能在第一级台阶，后一次走了两步；也可能在第二级台阶，一次走了一步，所以到第三级台阶的方法为到第一第二级台阶方法之和<br>为什么不能在第一级台阶然后走两步到第三级台阶呢？<br>因为这样会经过第二级台阶，重复了  </p></blockquote><h4 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h4><p>$dp[i]&#x3D;dp[i-1]+dp[i-2]$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; stair;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        stair.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        stair.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num=stair[i<span class="number">-1</span>]+stair[i<span class="number">-2</span>];</span><br><span class="line">            stair.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stair[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火算法</title>
      <link href="/posts/a0d601b7.html"/>
      <url>/posts/a0d601b7.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1-简介"></a>1-简介</h3><p><strong>模拟退火算法（Simulated Annealing，SA）是一种模拟物理退火的过程而设计的随机优化算法</strong>，结合爬山法和随机行走算法，同时避免算法进入局部最优，早期用于组合优化，后来发展成一种通用的优化算法。</p><p>该算法采用类似于物理退火的过程，先在一个高温状态下（相当于算法随机搜索），然后逐渐退火，在每个温度下（相当于算法的每一次状态转移），徐徐冷却（相当于算法局部搜索），最终达到物理基态（相当于算法找到最优解）。</p><p><strong>高温过程</strong>——增强粒子的热运动，使其偏离平衡位置，目的是消除系统原先可能存在的非均匀态；<br><strong>等温过程</strong>——退火过程中要让温度<em>慢慢降低</em>，在每一个温度下要达到热平衡状态，对于与环境换热而温度不变的封闭系统满足自由能较少定律，系统状态的自发变化总是朝自由能减少的方向进行，当自由能达到最小时，系统达到平衡态；<br><strong>冷却过程</strong>——使粒子热运动减弱并渐趋有序，系统能量逐渐下降，从而得到低能的晶体结构。当液体凝固为固体的晶态时退火过程完成。</p><p>因此模拟退火算法从某一高温出发，在高温状态下计算初始解，然后以预设的邻域函数产生一个扰动量，从而得到新的状态，即模拟粒子的无序运动，比较新旧状态下的能量，即目标函数的解。如果新状态的能量小于旧状态，则状态发生转化；如果新状态的能量大于旧状态，则以Metropolis接受准则发生转化。当状态稳定后，便可以看作达到了当前状态的最优解，便可以开始降温，在下一个温度继续迭代，最终达到低温的稳定状态，便得到了模拟退火算法产生的结果</p><p>该算法的<strong>关键点</strong>如下： 1、对固体退火过程的模拟； 2、采用<em>Metropolis接受准则</em>  [^1]； 3、用冷却进度表控制算法进程，使算法在多项式时间里给出一个近似解。 固体退火过程是SAA的物理背景；Metropolis接受准则使算法跳离局部最优 “陷阱”；而冷却进度表的合理选择是算法应用的前提。</p><p>[^1]:  以概率接受新状态，固体在恒定温度下达到热平衡的过程可以用Monte Carlo方法（计算机随机模拟方法）加以模拟。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2-原理"></a>2-原理</h3><p>假设材料在状态 $i$ 下的能量为 $E(i)$ ，那么物体在温度 $T$  时从状态 $i$ 进入状态 $j$ 时遵循如下规律：</p><ul><li>若$E(j) &lt; E(i)$ 则接受该状态被转化</li><li>若$E(j) \geq E(i)$  则有$e^ {\frac{E(i)-E(j)}{KT}}$ 概率被转化 (K是玻尔兹曼常数，T是材料温度)<blockquote><p>由于这个过程得到的新状态 $E(j)$ 完全依赖于前一个状态 $E(i)$ 而与更前面的状态无关，所以是一个马尔可夫过程[^2]</p></blockquote></li></ul><p>[^2]:每个状态值取决于前面有限个状态。（条件概率）下一个时间点的值只与当前值有关系，与以前没有关系，即未来决定于现在而不是过去。$P(X_{n+1}&#x3D;j|X_0&#x3D;i_0,X_1 &#x3D;i_1,X_2&#x3D;i_2, …,X_{n-1}&#x3D; i_{n-1}, X_n &#x3D; i)&#x3D; P(X_{n+1}&#x3D;j|X_n&#x3D;i)$ </p><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3-案例"></a>3-案例</h3><h4 id="观察函数图像"><a href="#观察函数图像" class="headerlink" title="观察函数图像"></a>观察函数图像</h4><p>考察的函数为$y&#x3D;3x^2-60x+9$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">x_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>*x**<span class="number">2</span>-<span class="number">60</span>*x+<span class="number">9</span></span><br><span class="line">x=[i <span class="keyword">for</span> i <span class="keyword">in</span> np.linspace(<span class="number">0</span>,<span class="number">100</span>)]</span><br><span class="line">y=<span class="built_in">map</span>(x_function,x)</span><br><span class="line">plt.plot(x,<span class="built_in">list</span>(y))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在$x&#x3D;10$ 处函数取得最小值</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="1-解空间"><a href="#1-解空间" class="headerlink" title="(1) 解空间"></a>(1) 解空间</h5><p>解空间就是定义域的范围，在此为$[0,100]$</p><h5 id="2-目标函数"><a href="#2-目标函数" class="headerlink" title="(2) 目标函数"></a>(2) 目标函数</h5><p>我们所要求最值的函数</p><h5 id="3-新解的产生"><a href="#3-新解的产生" class="headerlink" title="(3) 新解的产生"></a>(3) 新解的产生</h5><p>在此案例中直接通过加上一个微小的偏差bias来微调<br><code> x_new = x + np.random.uniform(-1,1)</code><br>bias从均匀分布$[-1,1)$ 中任意采样</p><h5 id="4-代价函数差"><a href="#4-代价函数差" class="headerlink" title="(4) 代价函数差"></a>(4) 代价函数差</h5><p>为前后两次函数值的差值$E(j)-E(i)$</p><h5 id="5-接受准则"><a href="#5-接受准则" class="headerlink" title="(5) 接受准则"></a>(5) 接受准则</h5><p>为算法的核心部分</p><ul><li>if $E(j)&lt;E(i)$ 则概率$P&#x3D;1$</li><li>else 概率$P&#x3D;e^ {\frac{E(i)-E(j)}{KT}}$<br>使用中可以把K当作1处理，温度T可以是任意尺度的值(比如初始T&#x3D;1)</li></ul><h5 id="6-降温"><a href="#6-降温" class="headerlink" title="(6) 降温"></a>(6) 降温</h5><p>选定一个降温系数 $a$ 进行降温处理，$T&#x3D;a*T$ ,以此得到新的温度(由于要缓慢降温，所以 $a$ 应该要接近1，比如$a&#x3D;0.999$)</p><h5 id="7-结束条件"><a href="#7-结束条件" class="headerlink" title="(7) 结束条件"></a>(7) 结束条件</h5><p>选定一个结束温度，当温度衰减到该值时结束算法，输出当前状态(比如$std&#x3D;0.0000001$)</p><h3 id="4-程序实现"><a href="#4-程序实现" class="headerlink" title="4-程序实现"></a>4-程序实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">T=<span class="number">1</span> <span class="comment"># 初始温度</span></span><br><span class="line">x=np.random.uniform(<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line">std=<span class="number">0.0000001</span> <span class="comment"># 终止温度</span></span><br><span class="line">a=<span class="number">0.999</span> <span class="comment"># 衰减率</span></span><br><span class="line"><span class="keyword">while</span> T&gt;std:</span><br><span class="line">    y=x_function(x)</span><br><span class="line">    x_new=x+np.random.uniform(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># 产生新值</span></span><br><span class="line">    <span class="keyword">if</span> x_new&gt;=<span class="number">0</span> <span class="keyword">and</span> x_new&lt;=<span class="number">100</span>:</span><br><span class="line">        y_new=x_function(x_new)</span><br><span class="line">        <span class="keyword">if</span> y_new&lt;y:</span><br><span class="line">            x=x_new</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p=np.exp((y-y_new)/T)</span><br><span class="line">            r=np.random.uniform(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> p&gt;r:</span><br><span class="line">                x=x_new</span><br><span class="line">    T=T*a</span><br><span class="line"><span class="built_in">print</span>(x,x_function(x))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 优化算法 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/mycss.css"/>
      <url>/css/mycss.css</url>
      
        <content type="html"><![CDATA[/* 首页文章卡片 */#recent-posts > .recent-post-item{    background:rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */.card-widget{    background:rgba(255, 255, 255, 0.9)!important;}/* 文章页面正文背景 */div#post{    background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page{    background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive{    background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag{    background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category{    background: rgba(255, 255, 255, 0.9);}body {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur),        default;}a,img {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur),        default;}/* 彩带 */.card-info-avatar:hover {    background: url(https://cdn.jsdelivr.net/gh/rigodlee/BLOGCDN/img/H3342af90d24b4d62b9bbfec9688ccc25M.gif);}#web_bg {    /* 背景图地址 */    background: url(/img/backg.jpeg);    /* 平铺 */    background-repeat: no-repeat;    /* 背景图大小 */    background-size: cover;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/1292233">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p529908155.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p529908155.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>发条橙AClockworkOrange(1971)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>斯坦利·库布里克</span></div>            <div class="douban-card-item"><span>主演: </span><span>马尔科姆·麦克道威尔/帕特里克·马基</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>1971-12-19(纽约首映)</span></div>            <div class="douban-card-item"><span>评分: </span><span>8.6</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/1303460">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img1.doubanio.com/view/photo/s_ratio_poster/public/p1078004649.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img1.doubanio.com/view/photo/s_ratio_poster/public/p1078004649.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>战栗黑洞IntheMouthofMadness(1994)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>约翰·卡朋特</span></div>            <div class="douban-card-item"><span>主演: </span><span>山姆·尼尔/朱莉·卡门</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>1994-12-10(黑色电影节)</span></div>            <div class="douban-card-item"><span>评分: </span><span>7.8</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/1291557">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p1910828286.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p1910828286.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>花样年华花樣年華(2000)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>王家卫</span></div>            <div class="douban-card-item"><span>主演: </span><span>梁朝伟/张曼玉</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>2000-09-29(中国香港)</span></div>            <div class="douban-card-item"><span>评分: </span><span>8.7</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/1291999">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p792381411.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p792381411.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>重庆森林重慶森林(1994)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>王家卫</span></div>            <div class="douban-card-item"><span>主演: </span><span>林青霞/金城武</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>1994-07-14(中国香港)</span></div>            <div class="douban-card-item"><span>评分: </span><span>8.8</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/3011308">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p1592298962.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p1592298962.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>孤儿怨Orphan(2009)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>佐米·希尔拉</span></div>            <div class="douban-card-item"><span>主演: </span><span>维拉·法米加/彼得·萨斯加德</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>2009-07-24(美国/加拿大)</span></div>            <div class="douban-card-item"><span>评分: </span><span>8.2</span></div>        </div>    </a></div><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/3604148">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p2452537144.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img9.doubanio.com/view/photo/s_ratio_poster/public/p2452537144.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>小丑回魂It(2017)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>安德斯·穆斯切蒂</span></div>            <div class="douban-card-item"><span>主演: </span><span>比尔·斯卡斯加德/杰登·马泰尔</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>2017-08-29(伦敦恐怖电影节)</span></div>            <div class="douban-card-item"><span>评分: </span><span>7.4</span></div>        </div>    </a></div>]]></content>
      
    </entry>
    
    
  
</search>
